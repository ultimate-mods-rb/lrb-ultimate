{func set_var
   ($var $in)
   {eval {` {set {, {var $var}} $in}}}
}
{func eval_var
   ($var)
   {eval {var $var}}
}
{func toggle_var
   ($var)
   {eval {` {set {, {var $var}} {! {eval_var $var}}}}}
}
{func lst_reset {do
   ($array {array 0})
   {foreach $entry {$this get data}
      {if_else {== {type $entry} kDataArray} ; just return whatever was passed if not array
         {switch {elem {find $entry type} 1}
            (uNormal
               {push_back $array {eval {elem $entry 0}}}
            )
            (uOnOFF
               {push_back $array
                  {sprintf
                     {localize os_onoff_fmt}
                     {localize {elem $entry 0}}
                     {localize {if_else {eval {elem {find $entry bool} 1}} on off}}
                  }
               }
            )
            #ifdef _SHIP
            {exit}
            #else
            {fail {sprint {elem {find $entry type} 1} " is an unknown type"}}
            #endif
         }
         {push_back $array {eval $entry}}
      }
   }
   {OS_LIST set_data $array}
}}
{func os_setup_common
   {title.lbl set text_token [title]}
   {lst_reset}
}
{func os_sel_common
   {foreach $cmd {find {elem [data] {OS_LIST selected_pos}} sel_script}
      {eval $cmd}
   }
   {lst_reset}
}
{func os_fix_pos
   {OS_LIST set_selected [pos]}
}
{func os_clear_pos
   {set [pos] 0}
}
{func force_drum_freestyle
   ($bool)
   {unless {gamemode get is_drum_trainer}
      {game foreach_local_player $p
         {if {&& $p {== {$p instrument} drum}}
            {$p force_fill $bool}
         }
      }
   }
}
{func clear_array
   ($obj $name)
   {while {size {$obj get_array $name}}
      {$obj remove ($name 0)}
   }
}
{func is_gig_random
   ($gig)
   {do
      ($random TRUE)
      {foreach_int $i 0 {$gig num_songs}
         {if {!= {$gig get_song $i} random}
            {set $random FALSE}
         }
      }
      $random
   }
}
{func apply_gfx_settings
   {$world iterate PostProc $p
      #ifdef HX_NG
      {$p set emulate_fps 60}
      {unless $scrnoise
         {$p set noise_intensity 0}
      }
      {unless $mbblend
         {$p set motion_blur_blend 0}
         {$p set motion_blur_weight 0}
      }
      #endif
      {unless $scrbloom
         {$p set bloom_intensity 0}
      }
   }
   {$world iterate CamShot $cs
      {unless $fxdof
         {$cs set use_depth_of_field FALSE}
      }
      {unless $camerashake
         {foreach_int $i 0 {$cs size (keyframes)}
            {$cs set (keyframes $i shake_noisefreq) 0}
            {$cs set (keyframes $i shake_noiseamp) 0}
            {$cs set (keyframes $i shake_maxangle x) 0}
            {$cs set (keyframes $i shake_maxangle y) 0}
         }
      }
   }
}
{func tolower ; fuck you harmonix
   ($string)
   {search_replace $string "A" "a" $string}
   {search_replace $string "B" "b" $string}
   {search_replace $string "C" "c" $string}
   {search_replace $string "D" "d" $string}
   {search_replace $string "E" "e" $string}
   {search_replace $string "F" "f" $string}
   {search_replace $string "G" "g" $string}
   {search_replace $string "H" "h" $string}
   {search_replace $string "I" "i" $string}
   {search_replace $string "J" "j" $string}
   {search_replace $string "K" "k" $string}
   {search_replace $string "L" "l" $string}
   {search_replace $string "M" "m" $string}
   {search_replace $string "N" "n" $string}
   {search_replace $string "O" "o" $string}
   {search_replace $string "P" "p" $string}
   {search_replace $string "Q" "q" $string}
   {search_replace $string "R" "r" $string}
   {search_replace $string "S" "s" $string}
   {search_replace $string "T" "t" $string}
   {search_replace $string "U" "u" $string}
   {search_replace $string "V" "v" $string}
   {search_replace $string "W" "w" $string}
   {search_replace $string "X" "x" $string}
   {search_replace $string "Y" "y" $string}
   {search_replace $string "Z" "z" $string}
   $string
}
{func char_code
   ($char)
   {switch $char
      (" " 32)
      ("!" 33)
      ("#" 35)
      ("$" 36)
      ("%" 37)
      ("&" 38)
      ("'" 39)
      ("(" 40)
      (")" 41)
      ("*" 42)
      ("+" 43)
      ("," 44)
      ("-" 45)
      ("." 46)
      ("/" 47)
      ("0" 48)
      ("1" 49)
      ("2" 50)
      ("3" 51)
      ("4" 52)
      ("5" 53)
      ("6" 54)
      ("7" 55)
      ("8" 56)
      ("9" 57)
      (":" 58)
      (";" 59)
      ("<" 60)
      ("=" 61)
      (">" 62)
      ("?" 63)
      ("@" 64)
      ("A" 65)
      ("B" 66)
      ("C" 67)
      ("D" 68)
      ("E" 69)
      ("F" 70)
      ("G" 71)
      ("H" 72)
      ("I" 73)
      ("J" 74)
      ("K" 75)
      ("L" 76)
      ("M" 77)
      ("N" 78)
      ("O" 79)
      ("P" 80)
      ("Q" 81)
      ("R" 82)
      ("S" 83)
      ("T" 84)
      ("U" 85)
      ("V" 86)
      ("W" 87)
      ("X" 88)
      ("Y" 89)
      ("Z" 90)
      ("[" 91)
      ("]" 93)
      ("^" 94)
      ("_" 95)
      ("`" 96)
      ("a" 97)
      ("b" 98)
      ("c" 99)
      ("d" 100)
      ("e" 101)
      ("f" 102)
      ("g" 103)
      ("h" 104)
      ("i" 105)
      ("j" 106)
      ("k" 107)
      ("l" 108)
      ("m" 109)
      ("n" 110)
      ("o" 111)
      ("p" 112)
      ("q" 113)
      ("r" 114)
      ("s" 115)
      ("t" 116)
      ("u" 117)
      ("v" 118)
      ("w" 119)
      ("x" 120)
      ("y" 121)
      ("z" 122)
      ("{" 123)
      ("|" 124)
      ("}" 125)
      ("~" 126)
      0
   }
}
; i've tried to optimise this func the best i could and this seems as fast as i can get it.
; if anyone smart is reading this pls make it better ;3
{func badcmp
   ($s1 $s2)
   {if_else {== $s1 $s2}
      0
      {do
         ($i 0)
         ($result 0)
         ($max {max {strlen $s1} {strlen $s2}})
            {while {< $i $max}
               {do
                  ($c1 {str_elem $s1 $i})
                  ($c2 {str_elem $s2 $i})
                  {unless {== $c1 $c2}
                     {set $result
                        {if_else {< {char_code $c1} {char_code $c2}}
                           -1
                           1
                        }
                     }
                     {set $i $max}
                  }
               }
               {++ $i}
            }
         $result
      }
   }
}
{func sti
   ($str)
   {switch $str
      ("0" 0)   ("1" 1)   ("2" 2)   ("3" 3)   ("4" 4)
      ("5" 5)   ("6" 6)   ("7" 7)   ("8" 8)   ("9" 9)

      ("a" 10)  ("b" 11)  ("c" 12)  ("d" 13)  ("e" 14)  ("f" 15)
      ("g" 16)  ("h" 17)  ("i" 18)  ("j" 19)  ("k" 20)  ("l" 21)
      ("m" 22)  ("n" 23)  ("o" 24)  ("p" 25)  ("q" 26)  ("r" 27)
      ("s" 28)  ("t" 29)  ("u" 30)  ("v" 31)  ("w" 32)  ("x" 33)
      ("y" 34)  ("z" 35)

      ("A" 36)  ("B" 37)  ("C" 38)  ("D" 39)  ("E" 40)  ("F" 41)
      ("G" 42)  ("H" 43)  ("I" 44)  ("J" 45)  ("K" 46)  ("L" 47)
      ("M" 48)  ("N" 49)  ("O" 50)  ("P" 51)  ("Q" 52)  ("R" 53)
      ("S" 54)  ("T" 55)  ("U" 56)  ("V" 57)  ("W" 58)  ("X" 59)
      ("Y" 60)  ("Z" 61)

      {fail {sprint "can't decode " $str}}
   }
}
{func its
   ($int)
   {switch $int
      (0 "0")   (1 "1")   (2 "2")   (3 "3")   (4 "4")
      (5 "5")   (6 "6")   (7 "7")   (8 "8")   (9 "9")

      (10 "a")  (11 "b")  (12 "c")  (13 "d")  (14 "e")  (15 "f")
      (16 "g")  (17 "h")  (18 "i")  (19 "j")  (20 "k")  (21 "l")
      (22 "m")  (23 "n")  (24 "o")  (25 "p")  (26 "q")  (27 "r")
      (28 "s")  (29 "t")  (30 "u")  (31 "v")  (32 "w")  (33 "x")
      (34 "y")  (35 "z")

      (36 "A")  (37 "B")  (38 "C")  (39 "D")  (40 "E")  (41 "F")
      (42 "G")  (43 "H")  (44 "I")  (45 "J")  (46 "K")  (47 "L")
      (48 "M")  (49 "N")  (50 "O")  (51 "P")  (52 "Q")  (53 "R")
      (54 "S")  (55 "T")  (56 "U")  (57 "V")  (58 "W")  (59 "X")
      (60 "Y")  (61 "Z")

      {fail {sprint "can't encode " $str}}
   }
}
{func siti
   ($str)
   {do
      ($result)
      ($len {strlen $str})
      {foreach_int $elem 0 $len
         {set $result {+ {* $result 10} {sti {str_elem $str $elem}}}}
      }
      $result
   }
}
{func sftf
   ($str)
   {do
      ($dotpos {str_elemof $str "."})
      {if_else $dotpos
         {do
            ($fracpart {substr $str {+ $dotpos 1} {strlen $str}})
            {+
               {siti {substr $str 0 $dotpos}}
               {/
                  {siti $fracpart}
                  {pow 10 {strlen $fracpart}}
               }
            }
         }
         {siti $str}
      }
   }
}
{func str_elemof
   ($str $char)
   {do
      ($len {strlen $str})
      ($found)
      ($elem)
      ($return)
      {while {&& {! $found} {> $len $elem}}
         {if_else {== {str_elem $str $elem} $char}
            {do
               {set $found TRUE}
               {set $return $elem}
            }
            {++ $elem}
         }
      }
      $return
   }
}
{func pow
   ($base $exp)
   {do
      ($return 1)
      {foreach_int $i 0 $exp
         {set $return {* $return $base}}
      }
      $return
   }
}
{func set_pad_map
   ($mapping)
   {foreach $pad (analog dualshock)
      {set_elem
         {find $syscfg joypad controller_mapping $pad} 1
         {switch $mapping
            (0 joypad)
            #ifdef HX_XBOX
            (1 ro_guitar_xbox)
            #else
            (1 hx_guitar_ps3)
            #endif
            (2 ro_guitar_ps3)
            (3 guitar)
            #ifdef HX_XBOX
            (4 hx_drums_xbox)
            #else
            (4 hx_drums_ps3)
            #endif
         }
      }
   }
}
{func get_song_metadata
   ($song $data)
   {do
      ($return)
      {if_else {challenge_mgr has_challenge}
         {print "unable to get metadata now\n"}
         {do
            {print "metadata " $song " " $data "\n"}
            {if {song_mgr has_song $song}
               {if_else {exists song_offer_provider}
                  {do
                     ($offer {song_offer_provider get_song_offer {song_offer_provider data_index $song}})
                     {if {$offer has_data $data}
                        {set $return {$offer get_data ($data)}}
                     }
                  }
                  {fail "song_offer_provider doesn't exist. can't get metadata now!"}
               }
            }
         }
      }
      $return
   }
}
{func ulti_cycle_free_camera
   {if $world
      {do
         ($free_cam_state {$world get_free_cam_state})
         {switch $free_cam_state
            (0
               {$world toggle_free_cam $cheat_controller}
               {cheat_display show "Free camera: world"}
               {$world next_free_cam_state}
            )
            (1
               {$world set_free_cam_parent
                  {find_obj $world player_vocal Head.mesh}
               } ; normally goes off player_vocals0 bone_head.mesh which neither exist in this game so we fix :)
               {$world set_free_cam_parent_dof 0 0 1}
               {$world set_free_cam_pos 0 -70 0}
               {$world set_free_cam_rot 0 0 0}
               {cheat_display show "Free camera: vocalist"}
               {$world next_free_cam_state}
            )
            (2
               {$world set_free_cam_parent
                  {find_obj $world player_vocal Head.mesh}
               }
               {$world set_free_cam_parent_dof 1 0 1} ; normally all are 1 but that caused it to go portrait mode
               {$world set_free_cam_pos 0 -70 0}
               {$world set_free_cam_rot 0 0 0}
               {cheat_display show "Free camera: vocalist fixed"}
               {$world next_free_cam_state}
            )
            (3
               {$world toggle_free_cam $cheat_controller}
               {cheat_display show "Free camera: frozen"}
               {$world next_free_cam_state}
            )
            (4
               {$world toggle_free_cam $cheat_controller}
               {cheat_display show "Free camera: off"}
               {$world next_free_cam_state}
            )
         }
      }
   }
}
